背景:
最开始决定编写zcc起始于大约2010年,那时候写了部分代码,但是2012年工作时候停了大约一年,到了2013年大约4月份的时候又开始编写.
旧代码可读性和架构设计(关于这个话题后面待续)太差全部扔掉了.所以这个版本是从零开始编写的.
zcc的名字起于偶然,zany c compiler,zany(笨拙的)正是我想要的意思,z也是我常用id的首字母.所以就这么愉快地决定了叫zcc.

现状:
zcc的实现依照ISO C89标准而来,剃掉部分我认为比较扯淡的feature:
1, K&R旧式风格的函数声明
2, 未声明函数的隐式声明
3, 如果没有type-specifier则隐式声明为int
如果你不知道上面的3个特性,请不要费精力弄清楚了,第1条是为了兼容70年代的代码,剩余两条隐式声明绝对是糟粕.

除掉上面的3条,剩余ISO C89的语法和语义理论上来说全部实现了.
正如我背景里写的zcc的开始编写到测试通过一个简单例程大约花了13个月,因为太烦躁中间大约停了3个月多,生成到AST的时候大约是2014年2月份.
生成到icode大约是2014年3月份,也就是说从AST到汇编输出大约写了3个月.但是这部分的代码是占了总共的2/3以上.也就是说最后1/3的时间
写了2/3的代码,到输出汇编的时候我才意识到架构设计的失败.没经验啊..

架构:
zcc现在的架构是先生成AST->icode->ASM
AST就是教科书里的抽象语法树,icode是另外一种双向链表连接的中间表示,每一条icode基本对应一条汇编,但是有些icode在输出的时候可能会被优化掉.
这是一个很简单的架构,但是很失败,因为匹配icode的时候信息缺失很严重,生成较优化的代码很困难.
后端的重写和重新设计势在必行.

将来:
全面测试.
中间表示改为SSA,代码生成改为DAG的tree match.
两年之后,我应该会实现这个目标.
